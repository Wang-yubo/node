### 10 HTTP基本原理2

##### 10.1 url补充

> url的核心结构 >>>
>
> 大多数URL 方案的URL 语法都建立在这个由9 部分构成的通用格式上：
> `<scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>`
>
> ![image-20200224153447746](..\images\image-20200224153447746.png)
>
> 几乎没有哪个URL 中包含了所有这些组件(不同类型的URL包含了里面的几个不同的部分)
> URL 最重要的3 个部分是方案（scheme）、主机（host）和路径（path）

##### 10.2 HTTP报文流入源端服务器

> HTTP 报文是在HTTP 应用程序之间发送的数据块。这些数据块以一些文本形式的元信息（meta-information）开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。这些报文在客户端、服务器和代理之间流动。术语“流入”、“流出”、“上游”及“下游”都是用来描述报文方向的。
>
> ![image-20200224161122729](..\images\image-20200224161122729.png)
>
> HTTP 使用术语流入（inbound）和流出（outbound）来描述事务处理（transaction）的方向。报文流入源端服务器，工作完成之后，会流回用户的Agent 代理中
>
> HTTP 报文会像河水一样流动。不管是请求报文还是响应报文，所有报文都会向下游（downstream） 流动。所有报文的发送者都在接收者的上游（upstream）
>
> ![image-20200224161208073](..\images\image-20200224161208073.png)

##### 10.3 报文格式详解

> ![image-20200224161252307](..\images\image-20200224161252307.png)
>
> 所有的HTTP 报文都可以分为两类： 请求报文（request message） 和响应报文（response message）。请求报文会向Web 服务器请求一个动作。响应报文会将请求的结果返回给客户端。请求和响应报文的基本报文结构相同。
>
> ```js
> //这是请求报文的格式：
> <method> <request-URL> <version>
> <headers>
> <entity-body>
> ```
>
> ```js
> //这是响应报文的格式（注意，只有起始行的语法有所不同）：
> <version> <status> <reason-phrase>
> <headers>
> <entity-body>
> ```
>
> 所有的HTTP 报文都以一个起始行作为开始。请求报文的起始行说明了要做些什么。响应报文的起始行说明发生了什么。
>
> 下面是对各部分的简要描述 >>>
>
> - 方法（method）>>> 
>
> 客户端希望服务器对资源执行的动作。是一个单独的词，比如GET、HEAD 或POST。
>
> - 请求URL（request-URL）>>> 
>
> 命名了所请求资源，或者URL 路径组件的完整URL。如果直接与服务器进行对话，只要URL 的路径组件是资源的绝对路径，通常就不会有什么问题——服务器可以假定自己是URL 的主机/ 端口。
>
> - 版本（version）>>>
>
> 报文所使用的HTTP 版本，其格式看起来是这样的：HTTP/`<major>.<minor>`其中主要版本号（major）和次要版本号（minor）都是整数。
>
> - 状态码（status-code）>>> 
>
> 这三位数字描述了请求过程中所发生的情况。每个状态码的第一位数字都用于描述状态的一般类别（“成功”、“出错”等）。
>
> - 原因短语（reason-phrase）>>>
>
> 数字状态码的可读版本，包含行终止序列之前的所有文本。本章稍后提供了HTTP 规范定义的所有状态码的原因短语示例。原因短语只对人类有意义，因此，比如说，尽管响应行HTTP/1.0 200 NOT OK 和 HTTP/1.0 200 OK 中原因短语的含义不同，但同样都会被当作成功指示处理。
>
> - 首部（header）>>>
>
> 可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号（:），然后是一个可选的空格，接着是一个值，最后是一个CRLF。首部是由一个空行（CRLF）结束的，表示了首部列表的结束和实体主体部分的开始。有些HTTP 版本，比如HTTP/1.1，要求有效的请求或响应报文中必须包含特定的首部
>
> - 实体的主体部分(entity-body)
>
> 实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实体的主体部分，有时，报文只是以一个CRLF 结束
>
> ![image-20200224163251361](..\images\image-20200224163251361.png)
>
> 最常用的就是GET和POST方法, 这两个方法从HTTP的报文格式上就可以知道,一个携带了主体数据一个没有携带而只是靠请求的参数进行数据传递
>
> GET 是最常用的方法。通常用于请求服务器发送某个资源。HTTP/1.1 要求服务器实现此方法
>
> ![image-20200224164534112](..\images\image-20200224164534112.png)
>
> 
>
> HEAD 方法与GET 方法的行为很类似，但服务器在响应中只返回首部。不会返回实体的主体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查。
>
> ![image-20200224164731606](..\images\image-20200224164731606.png)
>
> - 使用HEAD，可以在不获取资源的情 况下了解资源的情况（比如，判断其类型）；
>
> - 通过查看响应中的状态码，看看某个对象是否存在；
>
> - 通过查看首部，测试资源是否被修改了。
>
> 服务器开发者必须确保返回的首部与GET 请求所返回的首部完全相同。遵循HTTP/1.1 规范，就必须实现HEAD 方法
>
> 
>
> 与GET 从服务器读取文档相反，PUT 方法会向服务器写入文档。有些发布系统允许用户创建Web 页面，并用PUT 直接将其安装到Web 服务器上去,因为PUT 允许用户对内容进行修改，所以很多Web 服务器都要求在执行PUT 之前，用密码登录
>
> ![image-20200224164953244](..\images\image-20200224164953244.png)
>
> 
>
> POST 方法起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方
>
> ![image-20200224165029625](..\images\image-20200224165029625.png)
>
> POST 用于向服务器发送数据。PUT 用于向服务器上的资源（例如文件）中存储数据
>
> 
>
> TRACE 请求会在目的服务器端发起一个“环回”诊断。行程最后一站的服务器会弹回一条TRACE 响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间HTTP 应用程序组成的请求/ 响应链上，原始报文是否，以及如何被毁坏或修改过
>
> ![image-20200224165114140](..\images\image-20200224165114140.png)
>
> 
>
> OPTIONS 方法请求Web 服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法
>
> ![image-20200224165142975](..\images\image-20200224165142975.png)

##### 10.4 报文状态码详解

> 方法是用来告诉服务器做什么事情的，状态码则用来告诉客户端，发生了什么事情。
>
> 状态码分类 >>>
>
> ![image-20200224170827498](..\images\image-20200224170827498.png)
>
> 可以通过三位数字代码对不同状态码进行分类。
>
> - 200 到299 之间的状态码表示成功。
> - 300 到399 之间的代码表示资源已经被移走了。
> - 400 到499 之间的代码表示客户端的请求出错了。
> - 500 到599 之间的代码表示服务器出错了。
>
> 常见状态码 >>>
>
> ![image-20200224170852621](..\images\image-20200224170852621.png)

##### 10.5 报文首部详解

> HTTP 首部字段向请求和响应报文中添加了一些附加信息。本质上来说，它们只是一些名/值对的列表。
>
> ![image-20200224171024345](..\images\image-20200224171024345.png)
>
> HTTP 规范定义了几种首部字段。应用程序也可以随意发明自己所用的首部。HTTP首部可以分为以下几类。
>
> 1. 通用首部 >>> 既可以出现在请求报文中，也可以出现在响应报文中。
> 2. 请求首部 >>> 提供更多有关请求的信息。
> 3. 响应首部 >>> 提供更多有关响应的信息。
> 4. 实体首部 >>> 描述主体的长度和内容，或者资源自身。
> 5. 扩展首部 >>> 规范中没有定义的新首部。每个HTTP 首部都有一种简单的语法：名字后面跟着冒号（ ：），然后跟上可选的空格，再跟上字段值，最后是一个CRLF
>
> 有些首部提供了与报文相关的最基本的信息，它们被称为通用首部。它们像和事佬儿一样，不论报文是何类型，都为其提供一些有用信息
>
> ![image-20200224171233248](..\images\image-20200224171233248.png)
>
> 请求首部是只在请求报文中有意义的首部。用于说明是谁或什么在发送请求、请求源自何处，或者客户端的喜好及能力。服务器可以根据请求首部给出的客户端信息，试着为客户端提供更好的响应
>
> ![image-20200224171318709](..\images\image-20200224171318709.png)
>
> 
>
> Accept 首部为客户端提供了一种将其喜好和能力告知服务器的方式，包括它们想要什么，可以使用什么，以及最重要的，它们不想要什么。这样，服务器就可以根据这些额外信息，对要发送的内容做出更明智的决定。Accept 首部会使连接的两端都受益。客户端会得到它们想要的内容，服务器则不会浪费其时间和带宽来发送客户端无法使用的东西
>
> ![image-20200224172132539](..\images\image-20200224172132539.png)
>
> ![image-20200224172142999](..\images\image-20200224172142999.png)
>
> 
>
> 有时客户端希望为请求加上某些限制。比如，如果客户端已经有了一份文档副本，就希望只在服务器上的文档与客户端拥有的副本有所区别时，才请求服务器传输文档。通过条件请求首部，客户端就可以为请求加上这种限制，要求服务器在对请求进行响应之前，确保某个条件为真。
>
> ![image-20200224173046000](..\images\image-20200224173046000.png)
>
> ![image-20200224173101746](..\images\image-20200224173101746.png)
>
> 
>
> HTTP 本身就支持一种简单的机制，可以对请求进行质询/ 响应认证。这种机制要求客户端在获取特定的资源之前，先对自身进行认证，这样就可以使事务稍微安全一些。
>
> ![image-20200225133516224](..\images\image-20200225133516224.png)

##### 10.6 响应报文首部详解

> 响应报文有自己的响应首部集。响应首部为客户端提供了一些额外信息，比如谁在发送响应、响应者的功能，甚至与响应相关的一些特殊指令。这些首部有助于客户端处理响应，并在将来发起更好的请求
>
> ![image-20200225133743859](..\images\image-20200225133743859.png)
>
> 内容首部提供了与实体内容有关的特定信息，说明了其类型、尺寸以及处理它所需的其他有用信息。比如，Web 浏览器可以通过查看返回的内容类型，得知如何显示对象。
>
> ![image-20200225133911576](..\images\image-20200225133911576.png)
>
> 抓包小工具 Fiddler
>
> ![image-20200225140221501](..\images\image-20200225140221501.png)

