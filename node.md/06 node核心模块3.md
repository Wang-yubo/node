### 06 node核心模块3

##### 6.1 buffer模块

> - Buffer对象是node处理二进制数据的一个接口 , 它是原生node提供的全局对象 , 可以直接使用 , 不需要require("buffer")
> - JavaScript比较擅长处理字符串，对于处理二进制数据（比如TCP数据流），就不太擅长。Buffer对象就是为了解决这个问题而设计的。它是一个构造函数，生成的实例代表了V8引擎分配的一段内存，是一个类似数组的对象，成员都为0到255的整数值，即一个8位的字节。
>
> ![image-20200222162734369](..\images\image-20200222162734369.png)
>
> ![image-20200222162802064](..\images\image-20200222162802064.png)
>
> Buffer作为构造函数，可以用new命令生成一个实例，它可以接受多种形式的参数 >>>
>
> ![image-20200222164203619](..\images\image-20200222164203619.png)
>
> `buffer`值的转换 >>>
>
> `Buffer`对象与字符串的互相转换，需要指定编码格式。目前，Buffer对象支持以下编码格式 >>>
>
> 1. `ascii`
> 2. `utf8`
> 3. `utf16le：UTF`-16的小端编码，支持大于U+10000的四字节字符。
> 4. `ucs2`：utf16le的别名。
> 5. `base64`
> 6. `hex`：将每个字节转为两个十六进制字符。
>
> 用的比较多的就是base64了
>
> 
>
> `buffer`的基本方法 >>>
>
> `Buffer.isEncoding()` >>> 方法返回一个布尔值，表示Buffer实例是否为指定编码 , 一般是检测当前环境是否支持某些编码格式
>
> ![image-20200222202725936](..\images\image-20200222202725936.png)
>
> ![image-20200222202742069](..\images\image-20200222202742069.png)
>
> 
>
> `Buffer.isBuffer()` >>> 方法接受一个对象作为参数，返回一个布尔值，表示该对象是否为Buffer实例。
>
> ![image-20200222203430259](..\images\image-20200222203430259.png)
>
> ![image-20200222203452852](..\images\image-20200222203452852.png)
>
> 
>
> `Buffer.byteLength()` >>> 方法返回字符串实际占据的字节长度，默认编码方式为`utf8`
>
> ![image-20200222203653351](..\images\image-20200222203653351.png)
>
> ![image-20200222203718900](..\images\image-20200222203718900.png)
>
> 
>
> `Buffer.concat()` >>> 方法将一组Buffer对象合并为一个Buffer对象
>
> ![image-20200222220545334](..\images\image-20200222220545334.png)
>
> ![image-20200222220612300](..\images\image-20200222220612300.png)
>
> 需要注意的是，如果Buffer.concat的参数数组只有一个成员，就直接返回该成员。如果有多个成员，就返回一个多个成员合并的新Buffer对象。
>
> Buffer.concat方法还可以接受第二个参数，指定合并后Buffer对象的总长度 >>> 
>
> ![image-20200222220724722](..\images\image-20200222220724722.png)
>
> ![image-20200222220745613](F:\前端开发\learn node.js\images\image-20200222220745613.png)
>
> 省略第二个参数时，Node内部会计算出这个值，然后再据此进行合并运算。因此，显式提供这个参数，能提高运行速度。
>
> 
>
> buffer的实例方法 >>>
>
> `write()` >>> write方法可以向指定的Buffer对象写入数据。它的第一个参数是所写入的内容，第二个参数（可省略）是所写入的起始位置（默认从0开始），第三个参数（可省略）是编码方式，默认为utf8。
>
> ![image-20200222221945482](..\images\image-20200222221945482.png)
>
> ![image-20200222222007171](..\images\image-20200222222007171.png)
>
> `slice()` >>> slice方法返回一个按照指定位置、从原对象切割出来的Buffer实例。它的两个参数分别为切割的起始位置和终止位置。
>
> ![image-20200222222421038](..\images\image-20200222222421038.png)
>
> ![image-20200222222446491](..\images\image-20200222222446491.png)
>
> `toString()` >>> 该方法将Buffer实例，按照指定编码（默认为utf8）转为字符串。
>
> toString方法可以只返回指定位置内存的内容，它的第二个参数表示起始位置，第三个参数表示终止位置，两者都是从0开始计算。
>
> ![image-20200223135719955](..\images\image-20200223135719955.png)
>
> ![image-20200223135735122](..\images\image-20200223135735122.png)
>
> 
>
> buffer的实例属性 >>>
>
> length属性 >>> length属性返回Buffer对象所占据的内存长度。注意，这个值与Buffer对象的内容无关。
>
> ![image-20200223140142252](..\images\image-20200223140142252.png)
>
> ![image-20200223140206418](..\images\image-20200223140206418.png)
>
> - 上面代码中，不管写入什么内容，length属性总是返回Buffer对象的空间长度。如果想知道一个字符串所占据的字节长度，可以将其传入Buffer.byteLength方法。
> - length属性是可写的，但是这会导致未定义的行为，不建议使用。如果想修改Buffer对象的长度，建议使用slice方法返回一个新的Buffer对象。

