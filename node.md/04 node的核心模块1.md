### 04 node的核心模块1

##### 4.1 path模块

> 如何去得知自己的当前位置和目标文件的位置 , 这是作为对本地文件进行操作的基础
>
> Path模块引进的是一个对象 , 内部有很多的属性方法
>
> ![image-20200221144247044](..\images\image-20200221144247044.png)
>
> ![image-20200221144313837](..\images\image-20200221144313837.png)
>
> `path.join()`方法 >>> 
>
> 用于连接路径 , 该方法的主要用途在于会正确使用当前系统的路径分隔符 , Unix系统是`"/"` , Windows系统是`"\"`
>
> ![image-20200221144912338](..\images\image-20200221144912338.png)
>
> ![image-20200221144941998](..\images\image-20200221144941998.png)
>
> - `__dirname` >>> 当前文件(当前指令所在)所在的上级目录(绝对路径) , 一般会在后面拼接文件路径或其他目录
> - `__filename` >>> 当前文件(当前指令所在)所在的目录名称+文件名称(绝对路径) , 已经到文件名了 , 后面不需要再拼接其他文件路径
>
> 
>
> `path.resolve()` >>>
>
> - 用于将相对路径转为绝对路径 ,
> - 他可以接受多个参数 , 依次表示所要进入的路径 , 直到将最后一个参数转为绝对路径 ,
> - 如果根据参数无法得到绝对路径 , 就以当前所在路径作为基准 , 
> - 除了根目录 , 该方法的返回值都不带结尾的斜杠
>
> `path.join`如果不加第一个参数(`__dirname`或`__filename`) , 他就是简单地将后面的所有参数拼成一个相对路径 >>>
>
> ![image-20200221151601087](..\images\image-20200221151601087.png)
>
> ![image-20200221151629313](..\images\image-20200221151629313.png)
>
> 但是`path.resolve`如果不加第一个参数 , 他仍然返回一个绝对路径 , 但是它只匹配最后一个参数的文件 , 前面的参数会造成重复的路径错误 >>>
>
> ![image-20200221153925213](..\images\image-20200221153925213.png)
>
> ![image-20200221153945844](..\images\image-20200221153945844.png)
>
> 在同样都有第一个参数的情况下 , `path.resolve`和`path.join`没什么区别 >>>
>
> ![image-20200221154417876](..\images\image-20200221154417876.png)
>
> ![image-20200221154435959](..\images\image-20200221154435959.png)
>
> 
>
> `path.relative()` >>>
>
> - 该方法接受两个参数 , 这两个参数都应该是绝对路径
> - 该方法返回第二个路径相对于第一个路径的那个相对路径(老师的理解)
>
> 实例代码 >>>
>
> ![image-20200221161539652](..\images\image-20200221161539652.png)
>
> ![image-20200221161643126](..\images\image-20200221161643126.png)
>
> ![image-20200221161841617](..\images\image-20200221161841617.png)
>
> 这是从`localPath`到`nowPath`的结果 , 现在调整两个参数的前后位置 >>>
>
> ![image-20200221162155718](..\images\image-20200221162155718.png)
>
> ![image-20200221162137109](..\images\image-20200221162137109.png)
>
> 从这两个结果可以分析出这个相对路径是以第一个参数为起点 , 以第二个参数为终点 , 这其中经过的路径 , 所以应该是第一个参数相对于第二个参数的路径 , 这点我和老师的理解不同
>
> 
>
> `Path.parse()`>>>
>
> 该方法可以返回路径各部分的信息
>
> 实例代码 >>>
>
> ![image-20200221165601679](..\images\image-20200221165601679.png)
>
> ![image-20200221165626995](..\images\image-20200221165626995.png)
>
> ![image-20200221165647460](..\images\image-20200221165647460.png)
>
> 参数详解 >>>
>
> `root` >>> 路径的根目录 , 一般都是盘符(linux下就是/)
>
> `dir` >>> 就是文件所在的绝对路径(`dirname`模式下这就是, 文件所在目录的上级目录)
>
> `base` >>> 文件的基本信息(`dirname`模式下这就是, 文件所在目录相对于上级目录的相对路径)
>
> `ext` >>> 文件拓展名(`dirname`模式下, 没有后缀名,就是空值)
>
> `name`>>> 文件名(`dirname`模式下,这个就是文件夹名称)
>
> 
>
> `path`模块中的其他参数详解 >>>
>
> 1. `basename(path):path.basename(“pathaddr”,”filtterString”)` 方法返回 path 的最后一部分(`filename`下就是文件名字+后缀名, `dirname`下就是文件所在的最后一个层级的目录名)
>
> 2. `delimiter`:提供不同平台特定的路径定界符 >>>windows平台分号 , Linux系统是冒号
>
>    ![image-20200221195506628](..\images\image-20200221195506628.png)
>
>    ![image-20200221195700718](..\images\image-20200221195700718.png)
>
> 3. `dirname(path)`:返回`"pathaddr"`的目录名称
>
> 4. `extname(path)` : 返回 `path` 的扩展名，从最后一次出现 .（句点）字符到 `path` 最后一部分的字符串结束。 如果在 `path` 的最后一部分中没有 . ，或者如果 path 的基本名称（参阅 `path.basename()`）除了第一个字符以外没有 .，则返回空字符串
>
> 5. `format(pathObject)`: 方法从对象返回路径字符串。 与 path.parse() 相反。
>
>    ![image-20200221200507189](..\images\image-20200221200507189.png)
>
>    ![image-20200221200534217](..\images\image-20200221200534217.png)
>
>    
>
> 6. `isAbsolute(path)`:检测一个路径是否是绝对路径,如果path是个空string,则返回false
>
> 7. `normalize(path)`:规范化给定的 path，解析 '..' 和 '.' 片段。当找到多个连续的路径段分隔字符时（\），则它们将被替换为单个平台特定的路径段分隔符（\）。 尾部的分隔符会保留。如果 path 是零长度的字符串，则返回 '.'，表示当前工作目录。

