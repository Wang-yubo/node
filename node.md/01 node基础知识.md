### 01 node基础知识

##### 1.1 node的下载与安装

> ![image-20200218195030883](..\images\image-20200218195030883.png)
>
> 傻瓜式安装 >>> 但是务必勾选`add to path`
>
> ![image-20200218195146874](..\images\image-20200218195146874.png)
>
> 忘了的话就要手动添加环境变量了 >>>
>
> 打开高级系统设置 >>> 
>
> ![image-20200218195405559](..\images\image-20200218195405559.png)
>
> 点击环境变量 >>>
>
> ![image-20200218195336121](..\images\image-20200218195336121.png)
>
> 点击path >>>
>
> ![image-20200218195501446](..\images\image-20200218195501446.png)
>
> 我现在这里是有的 >>> 如果没有的话就需要把nodejs的目录添加到这里面去
>
> ![image-20200218200228786](..\images\image-20200218200228786.png)

##### 1.2 node的启动与运行

> node "js文件地址" >>>
>
> ![image-20200218200935027](..\images\image-20200218200935027.png)
>
> ```nginx
> λ node demo.js
> ```
>
> ![image-20200218201008339](..\images\image-20200218201008339.png)
>
> 直接输入node指令 >>> 进入node环境
>
> ![image-20200218201524593](..\images\image-20200218201524593.png)
>
> 光标指示的命令行允许你运行一些js代码 >>>
>
> ![image-20200218201905001](..\images\image-20200218201905001.png)

##### 1.3 node的核心概念值非阻塞I/O

> - I/O是input输入和output输出的意思
> - 在访问磁盘和网络这样的I/O请求时比较慢 , 所以我们希望 , 在读取文件和通过网络发送消息时 , 运行平台不会阻塞业务逻辑的执行
> - node用三种技术来解决这个问题 : 事件 , 异步API , 非阻塞I/O
> - 在node程序员看来 , 非阻塞是个底层术语 , 意思是你的程序可以在做其他事情时发起一个请求来获取网络资源 , 然后当网络操作完成时 , 将会运行一个回调函数来处理这个操作的结果
>
> ![image-20200219144448526](..\images\image-20200219144448526.png)
>
> 同步式I/O是指 >>>
>
> 线程在执行中如果遇到磁盘读写或网络通信(统称为I/O操作) , 通常要耗费较长的时间 , 这时操作系统会剥夺这个线程的CPU控制权 , 使其暂停执行 , 同时将资源让给其他的工作线程 , 这种线程调度方式称为阻塞 , 当I/O操作完成时 , 操作系统将这个线程的阻塞状态解除 , 恢复其对CPU的控制权 , 令其继续执行 , 这种I/O模式就是通常的同步式I/O或阻塞式I/O
>
> 多线程同步式I/O >>>
>
> ![image-20200219145103099](..\images\image-20200219145103099.png)
>
> 
>
> 异步式I/O或非阻塞式I/O则针对所有I/O操作不采用阻塞的策略 >>>
>
> 当线程遇到I/O操作时 , 不会以阻塞的方式等待I/O操作的完成或数据的返回 , 而只是将I/O请求发送给操作系统 , 继续执行下一条语句 , 当操作系统完成I/O操作时 , 以事件的的形式通知执行I/O操作的线程 , 线程会在特定时候处理这个事件 , 为了处理异步I/O , 线程必须由事件循环 , 不断地检查有没有未处理的事件 , 依次予以处理
>
> 单线程异步式I/O >>>
>
> ![image-20200219145911920](..\images\image-20200219145911920.png)
>
> 单线程事件驱动的异步式I/O比传统的多线程阻塞式I/O究竟好在哪里 >>>
>
> 简而言之 , 异步式I/O就是少了多线程的开销 , 对操作系统来说 , 创建一个线程 的代价是十分昂贵的 , 需要给它分配内存 , 列入调度 , 同时在线程切换的时候还要执行内存换页 , CPU的缓存被清空 , 切换回来的时候还要重新从内存中读取信息 , 破坏了数据的局部性
>
> ![image-20200219150640939](..\images\image-20200219150640939.png)

##### 1.4 Node与V8

> ![image-20200219151608499](..\images\image-20200219151608499.png)
>
> libuv负责处理I/O 的。V8 负责JavaScript 代码的解释和执行。用C++绑定层可将libuv 和V8 结合起来。

##### 1.5 事件循环

> Node.js程序由事件循环开始 , 到事件循环结束 , 所有的逻辑都是事件的回调函数 , 所以Node.js始终在事件循环中 , 程序入口就是事件循环第一个事件的回调函数
>
> 事件的回调函数在执行的的过程中 , 可能会发出I/O请求或直接发射(emit)事件 , 执行完毕后再返回事件循环 , 事件循环会检查事件队列中有没有未处理的事件 , 直到程序结束
>
> ![image-20200219152105526](..\images\image-20200219152105526.png)

##### 1.6 npm的基本指令集

> 安装模块不指定版本号 , 默认安装最新的版本 >>>
>
> ```nginx
> λ npm install packagename
> ```
>
> 安装指定版本的模块 >>>
>
> ```nginx
> λ npm install packagename 0.0.1
> ```
>
> 安装全局的模块 >>> 不加参数的时候默认安装本地模块 
>
> ```nginx
> λ npm install packagename -g 或 --global
> ```
>
> 安装生产环境依赖 >>> `--save`、`-S`参数意思是把模块的版本信息保存到`dependencies`（生产环境依赖）中，即你的`package.json`文件的`dependencies`字段中；
>
> ```nginx
> λ npm install packagename --save 或 -S
> ```
>
> 安装开发环境依赖 >>> `--save-dev` 、 `-D`参数意思是把模块版本信息保存到`devDependencies`（开发环境依赖）中，即你的`package.json`文件的`devDependencies`字段中；
>
> ```nginx
> λ npm install packagename --save-dev 或 -D
> ```
>
> 卸载已经安装的模块 >>>
>
> ```nginx
> λ npm uninstall packagename [options]
> ```
>
> 后面的`options`参数意思与安装时候的意思一样,与这个命令相同的还有npm remove 、npm rm、npm r 、 npm un 、 npm unlink 这几个命令功能和npm uninstall基本一样
>
> 检查新版本的指令 >>> 这个命令会列出所有已经过时了的模块
>
> ```nginx
> λ npm outdated
> ```
>
> 更新新版本的指令 >>> 对于已经过时了的模块可以使该命令去更新
>
> ```nginx
> λ npm update [-g]
> ```
>
> 指定更新某个包 >>>
>
> ```nginx
> λ npm updata [包名称]
> ```

